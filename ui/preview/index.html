<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FORMATnPACKAGE – UI Preview</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24..48,300..700,0..1,-50..200&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/theme.css">
  <link rel="stylesheet" href="../styles/layout.css">
  <!-- Import map for Material Web -->
  <script type="importmap">
    {
      "imports": {
        "@material/web/": "https://unpkg.com/@material/web@1.5.1/"
      }
    }
  </script>
  <script type="module">
    import "@material/web/button/filled-button.js";
    import "@material/web/textfield/filled-text-field.js";
    import "@material/web/icon/icon.js";
    import "@material/web/iconbutton/filled-icon-button.js";
    import "@material/web/list/list.js";
    import "@material/web/list/list-item.js";
    import "@material/web/chips/assist-chip.js";
  </script>
</head>
<body>
  <header class="app-bar">
    <md-filled-icon-button id="menuBtn" appearance="outlined" title="Menu">
      <span class="material-symbols-outlined" slot="icon">menu</span>
    </md-filled-icon-button>
    <span class="material-symbols-outlined">inventory_2</span>
    <div class="app-title">FORMATnPACKAGE</div>
    <div style="flex:1"></div>
    <md-filled-icon-button id="themeToggle" title="Toggle dark mode" appearance="outlined">
      <span class="material-symbols-outlined" slot="icon">dark_mode</span>
    </md-filled-icon-button>
  </header>
  <div class="instructions">
    <div class="note">
      Tip: Click <strong>Choose folder</strong> (or <strong>Scan</strong>) to select a folder to scan. Use <em>Remember folder</em> to keep access between visits. Filters accept space-separated extensions (e.g. <code>.png .jpg .json</code>).
    </div>
  </div>

  <main class="container">
    <section class="section">
      <h3>Inputs</h3>
      <div class="grid">
        <div>
          <label for="folderPicker" class="label">Select folder to scan</label>
          <input id="folderPicker" type="file" webkitdirectory directory multiple style="width:100%; padding:.5rem;" />
        </div>
        <div>
          <md-filled-text-field id="maxFiles" label="Max files to process (0 = all)" type="number" value="0"></md-filled-text-field>
        </div>
        <div>
          <md-filled-text-field id="extensions" label="Extensions filter (space-separated)" value=".tif .tiff .png .jpg .json .txt"></md-filled-text-field>
        </div>
        <div>
          <md-filled-text-field id="outputDir" label="Output directory" value="C:\\Users\\ravery\\Desktop\\compression_results"></md-filled-text-field>
        </div>
      </div>

      <div style="margin-top:1rem; display:flex; gap:.5rem; align-items:center;">
        <md-filled-button id="scanBtn">
          <span class="material-symbols-outlined" slot="icon">search</span>
          Scan
        </md-filled-button>
        <md-filled-button id="chooseFolderBtn" appearance="outlined">
          <span class="material-symbols-outlined" slot="icon">file_upload</span>
          Choose folder
        </md-filled-button>
        <md-filled-button id="runBtn">
          <span class="material-symbols-outlined" slot="icon">play_arrow</span>
          Run
        </md-filled-button>
        <md-filled-button appearance="tonal" id="clearBtn">
          <span class="material-symbols-outlined" slot="icon">refresh</span>
          Clear
        </md-filled-button>
        <label style="display:flex; align-items:center; gap:.25rem; margin-left:8px; white-space:nowrap;">
          <input type="checkbox" id="rememberFolder" />
          <small>Remember folder</small>
        </label>
        <div id="savedFolderArea" style="display:none; margin-left:8px; align-items:center; gap:.5rem;">
          <div id="savedFolderLabel" style="font-size:0.85rem; opacity:0.9"></div>
          <md-filled-button id="clearSavedBtn" appearance="outlined">Forget</md-filled-button>
        </div>
        <div id="savedFoldersBox" style="margin-left:8px;">
          <!-- saved folders list will be rendered here -->
        </div>
        <div id="spinner" class="spinner hidden" title="Scanning"></div>
      </div>

      <div id="progressArea" class="section" style="margin-top:1rem; display:none;">
        <div style="display:flex; align-items:center; gap:1rem;">
          <div style="flex:1">
            <div id="progressBarContainer" class="progress-bar-container"><div id="progressBar" class="progress-bar" style="width:0%"></div></div>
          </div>
          <div id="progressText">0 / 0</div>
        </div>
      </div>
      <div id="compressionSummary" style="margin-top:.75rem; display:none;">
        <strong>Estimated packaging:</strong>
        <div id="estText" style="font-size:.95rem; margin-top:.25rem"></div>
      </div>
      <div class="saved-folders" id="savedFoldersList" style="display:none;"></div>
    </section>

    <section class="section" id="resultsSection" style="display:none;">
      <h3>Scan Results</h3>
      <div class="grid">
        <div>
          <canvas id="typeChart" width="400" height="250"></canvas>
        </div>
        <div>
          <canvas id="sizeChart" width="400" height="250"></canvas>
        </div>
      </div>

      <h4 style="margin-top:1rem">Top files (by size)</h4>
      <md-list id="topFiles"></md-list>
    </section>

    <section class="section" id="scansSection" style="display:none;">
      <h3>Saved Scans</h3>
      <div id="scansGrid" class="scans-grid"></div>
      <div style="margin-top:.75rem; display:flex; justify-content:flex-end; gap:.5rem;">
        <md-filled-button id="clearAllScans" appearance="outlined">Clear All Scans</md-filled-button>
      </div>
    </section>

    <div class="footer">This preview scans a selected folder in-browser (no server). Use the folder picker to choose files.</div>
  </main>

  <!-- Mobile bottom toolbar -->
  <div class="mobile-toolbar" id="mobileToolbar" aria-hidden="false">
    <button id="mobileScanBtn" title="Scan" aria-label="Scan"><span class="material-symbols-outlined">search</span></button>
    <button id="mobileChooseBtn" title="Choose folder" aria-label="Choose folder"><span class="material-symbols-outlined">folder_open</span></button>
    <button id="mobileRunBtn" title="Run" aria-label="Run"><span class="material-symbols-outlined">play_arrow</span></button>
    <button id="mobileClearBtn" title="Clear" aria-label="Clear"><span class="material-symbols-outlined">refresh</span></button>
    <button id="mobileThemeBtn" title="Toggle theme" aria-label="Toggle theme"><span class="material-symbols-outlined">dark_mode</span></button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Helper functions
    function fmtBytes(bytes){
      if(bytes===0) return '0 B';
      const sizes=['B','KB','MB','GB','TB'];
      const i=Math.floor(Math.log(bytes)/Math.log(1024));
      return (bytes/Math.pow(1024,i)).toFixed(i?1:0)+' '+sizes[i];
    }

    const folderPicker = document.getElementById('folderPicker');
    const scanBtn = document.getElementById('scanBtn');
    const chooseFolderBtn = document.getElementById('chooseFolderBtn');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
    const spinner = document.getElementById('spinner');
    const progressArea = document.getElementById('progressArea');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const resultsSection = document.getElementById('resultsSection');
    const topFiles = document.getElementById('topFiles');

    let lastScan = null;
    let lastSavedScanId = null;
    const rememberFolder = document.getElementById('rememberFolder');
    const savedFolderArea = document.getElementById('savedFolderArea');
    const savedFolderLabel = document.getElementById('savedFolderLabel');
    const clearSavedBtn = document.getElementById('clearSavedBtn');
    const compressionSummary = document.getElementById('compressionSummary');
    const estText = document.getElementById('estText');

    function setSpinner(show){
      spinner.classList.toggle('hidden', !show);
    }

    function updateProgress(done, total){
      const pct = total? Math.round((done/total)*100):0;
      progressBar.style.width = pct + '%';
      progressText.textContent = `${done} / ${total}`;
    }

    // File System Access API helpers + IndexedDB persistence helpers
    const DB_NAME = 'FORMATnPACKAGE_handles_v1';
    function openDB(){
      return new Promise((resolve, reject)=>{
        // bump DB version to 2 to add 'scans' store when needed
        const r = indexedDB.open(DB_NAME, 2);
        r.onupgradeneeded = ()=>{
          const db = r.result;
          if(!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
          if(!db.objectStoreNames.contains('scans')) db.createObjectStore('scans');
        };
        r.onsuccess = ()=>resolve(r.result);
        r.onerror = ()=>reject(r.error);
      });
    }
    async function putHandle(key, handle){
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction('handles','readwrite');
        tx.objectStore('handles').put(handle, key);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
    async function getHandle(key){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('handles','readonly');
        const req = tx.objectStore('handles').get(key);
        req.onsuccess = ()=>res(req.result);
        req.onerror = ()=>rej(req.error);
      });
    }
    async function removeHandle(key){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('handles','readwrite');
        tx.objectStore('handles').delete(key);
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }

    async function traverseDirHandle(dirHandle){
      const files = [];
      async function traverse(handle){
        for await (const entry of handle.values()){
          if(entry.kind === 'file'){
            try{ files.push(await entry.getFile()); }catch(e){}
          } else if(entry.kind === 'directory'){
            await traverse(entry);
          }
        }
      }
      await traverse(dirHandle);
      return files;
    }

    async function useStoredHandleIfAvailable(){
      try{
        // Prefer any saved handles in the DB (new multi-save). Use the first available.
        const saved = await listAllSavedHandles();
        if(saved && saved.length){
          const id = saved[0].id;
          const rec = await getHandle(id);
          const handle = rec && rec.handle ? rec.handle : rec;
          if(handle){
            if(typeof handle.requestPermission === 'function'){
              const perm = await handle.requestPermission({mode:'read'});
              if(perm === 'granted'){
                const files = await traverseDirHandle(handle);
                return {handle, files};
              }
            } else {
              const files = await traverseDirHandle(handle);
              return {handle, files};
            }
          }
        }
        // legacy single-key fallback
        const stored = await getHandle('dir').catch(()=>null);
        if(stored){
          const handle = stored.handle || stored;
          if(handle){
            if(typeof handle.requestPermission === 'function'){
              const perm = await handle.requestPermission({mode:'read'});
              if(perm === 'granted'){
                const files = await traverseDirHandle(handle);
                return {handle, files};
              }
            } else {
              const files = await traverseDirHandle(handle);
              return {handle, files};
            }
          }
        }
      }catch(e){ console.warn('No stored handle available or permission denied', e); }
      return null;
    }

    // List all saved handles (returns array of {id, name})
    async function listAllSavedHandles(){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('handles','readonly');
        const store = tx.objectStore('handles');
        const out = [];
        store.openCursor().onsuccess = (ev)=>{
          const cur = ev.target.result;
          if(cur){
            const key = cur.key;
            const val = cur.value;
            let name = '';
            if(val && typeof val === 'object'){
              name = val.name || (val.handle && val.handle.name) || String(key);
            } else if(val && typeof val.name === 'string'){
              name = val.name;
            } else {
              name = String(key);
            }
            out.push({id:key, name});
            cur.continue();
          } else {
            res(out);
          }
        };
        store.openCursor().onerror = (e)=>rej(e);
      });
    }

    // Render saved folders UI (only show name)
    async function renderSavedFolders(){
      const list = document.getElementById('savedFoldersList');
      const box = document.getElementById('savedFoldersBox');
      const items = await listAllSavedHandles().catch(()=>[]);
      if(!items || !items.length){ list.style.display='none'; box.innerHTML=''; return; }
      list.style.display='flex';
      box.innerHTML = '';
      // render as compact pills in the toolbar area
      for(const it of items){
        const pill = document.createElement('div');
        pill.className = 'pill';
        const span = document.createElement('div');
        span.textContent = it.name;
        span.style.cursor = 'pointer';
        span.addEventListener('click', ()=> useSavedHandle(it.id));
        const btn = document.createElement('button');
        btn.textContent = '×';
        btn.title = 'Remove saved folder';
        btn.addEventListener('click', async (e)=>{ e.stopPropagation(); await removeHandle(it.id); await renderSavedFolders(); });
        pill.appendChild(span);
        pill.appendChild(btn);
        box.appendChild(pill);
        // also add to vertical list
        const v = document.createElement('div'); v.className='pill'; v.style.width='100%';
        const vspan = document.createElement('div'); vspan.textContent = it.name; vspan.style.cursor='pointer'; vspan.addEventListener('click', ()=> useSavedHandle(it.id));
        const vbtn = document.createElement('button'); vbtn.textContent='Use'; vbtn.addEventListener('click', ()=> useSavedHandle(it.id));
        const vdel = document.createElement('button'); vdel.textContent='Forget'; vdel.addEventListener('click', async (e)=>{ e.stopPropagation(); await removeHandle(it.id); await renderSavedFolders(); });
        v.appendChild(vspan); const right = document.createElement('div'); right.style.display='flex'; right.style.gap='.5rem'; right.appendChild(vbtn); right.appendChild(vdel); v.appendChild(right);
        list.appendChild(v);
      }
    }

    // Scans storage helpers
    async function putScan(id, record){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('scans','readwrite');
        tx.objectStore('scans').put(record, id);
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }
    async function listScans(){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('scans','readonly');
        const store = tx.objectStore('scans');
        const out = [];
        store.openCursor().onsuccess = (ev)=>{
          const cur = ev.target.result;
          if(cur){ out.push({id: cur.key, rec: cur.value}); cur.continue(); }
          else res(out);
        };
        store.openCursor().onerror = (e)=>rej(e);
      });
    }
    async function removeScan(id){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('scans','readwrite');
        tx.objectStore('scans').delete(id);
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }

    async function renderScans(){
      const container = document.getElementById('scansGrid');
      container.innerHTML = '';
      const items = await listScans().catch(()=>[]);
      if(!items || !items.length){ container.innerHTML = '<div style="opacity:.8">No saved scans yet.</div>'; return; }
      for(const it of items.reverse()){
        const r = it.rec;
        const card = document.createElement('div'); card.className='scan-card';
        const meta = document.createElement('div'); meta.className='meta';
        const name = document.createElement('div'); name.className='name'; name.textContent = r.name || 'Scan';
        const when = document.createElement('div'); when.className='small'; when.textContent = new Date(r.ts).toLocaleString();
        // checkmark for successful run
        if(r.ran){
          const chk = document.createElement('span'); chk.setAttribute('aria-hidden','true'); chk.style.color = 'limegreen'; chk.style.marginLeft = '8px'; chk.textContent = '✔';
          name.appendChild(chk);
        }
        meta.appendChild(name); meta.appendChild(when);
        const stats = document.createElement('div'); stats.className='stats';
        const files = document.createElement('div'); files.textContent = `${r.count} files`;
        const size = document.createElement('div'); size.textContent = fmtBytes(r.totalOrig||0);
        const comp = document.createElement('div'); comp.textContent = r.totalOrig? (Math.round(((r.totalOrig - (r.totalComp||0))/r.totalOrig)*100) + '%') : '-';
        stats.appendChild(files); stats.appendChild(size); stats.appendChild(comp);
        const actions = document.createElement('div'); actions.className='scan-actions';
        const openBtn = document.createElement('md-filled-button'); openBtn.textContent='Open'; openBtn.addEventListener('click', async ()=>{
          if(r.handleId){
            try{
              const recHandle = await getHandle(r.handleId);
              const handle = recHandle && recHandle.handle ? recHandle.handle : recHandle;
              if(handle){ const files = await traverseDirHandle(handle); if(files && files.length) startScan(files, { handleId: r.handleId, name: r.name }); }
            }catch(e){ console.warn(e); alert('Unable to open saved scan (permission or handle missing).'); }
          } else {
            alert('No folder handle saved for this scan.');
          }
        });
        const delBtn = document.createElement('md-filled-button'); delBtn.setAttribute('appearance','outlined'); delBtn.textContent='Forget'; delBtn.addEventListener('click', async ()=>{ await removeScan(it.id); await renderScans(); });
        actions.appendChild(openBtn); actions.appendChild(delBtn);
        card.appendChild(meta); card.appendChild(stats); card.appendChild(actions);
        container.appendChild(card);
      }
    }

    // Mark a saved scan as successfully run (UI-level flag)
    async function markScanSuccess(id){
      try{
        const db = await openDB();
        const tx = db.transaction('scans','readwrite');
        const store = tx.objectStore('scans');
        const req = store.get(id);
        req.onsuccess = async ()=>{
          const rec = req.result || {};
          rec.ran = true; rec.completedAt = Date.now();
          store.put(rec, id);
          tx.oncomplete = async ()=>{ await renderScans(); };
        };
        req.onerror = ()=>{ console.warn('Failed to mark scan success'); };
      }catch(e){ console.warn(e); }
    }

    async function useSavedHandle(id){
      try{
        const rec = await getHandle(id);
        const handle = rec && rec.handle ? rec.handle : rec;
        if(!handle){ alert('Saved handle not available'); return; }
        if(typeof handle.requestPermission === 'function'){
          const perm = await handle.requestPermission({mode:'read'});
          if(perm !== 'granted'){ alert('Permission not granted for that folder'); return; }
        }
        const files = await traverseDirHandle(handle);
        if(files && files.length) startScan(files, { handleId: id, name: handle.name });
      }catch(e){ console.warn(e); alert('Unable to access saved folder.'); }
    }

    async function saveSavedHandle(dirHandle){
      try{
        const id = 'h' + Date.now();
        const rec = { name: dirHandle.name || ('folder-' + id), handle: dirHandle };
        await putHandle(id, rec);
        await renderSavedFolders();
        return id;
      }catch(e){ console.warn('Saving handle failed', e); }
    }

    // Choose folder button — explicit picking
    chooseFolderBtn.addEventListener('click', async ()=>{
      if(!window.showDirectoryPicker){
        alert('Directory picker is not supported in this browser. Use the folder picker input.');
        folderPicker.click();
        return;
      }
      try{
        const dirHandle = await window.showDirectoryPicker();
        const files = await traverseDirHandle(dirHandle);
        let handleId = null;
        if(rememberFolder.checked){
          try{ handleId = await saveSavedHandle(dirHandle); }catch(e){ console.warn('Storing handle failed', e); }
        }
        await renderSavedFolders();
        startScan(files, { handleId, name: dirHandle.name });
      }catch(e){ console.warn('Directory pick cancelled', e); }
    });

    // Load stored handle on startup
    (async ()=>{
      try{
        const s = await useStoredHandleIfAvailable();
        if(s){
          savedFolderArea.style.display='flex';
          savedFolderLabel.textContent = s.handle.name || 'Saved folder';
          rememberFolder.checked = true;
        }
        await renderSavedFolders();
        await renderScans();
      }catch(e){}
    })();

    // Try to use the File System Access API to pick a directory (better UX)
    // Fallback: use the hidden file input with webkitdirectory
    scanBtn.addEventListener('click', async ()=>{
      // If we have a stored handle and user wants it, try to use it
      const stored = await getHandle('dir').catch(()=>null);
      if(stored){
        try{
          const perm = stored.queryPermission ? await stored.queryPermission({mode:'read'}) : 'prompt';
          if(perm === 'granted' || (perm === 'prompt' && (await stored.requestPermission({mode:'read'}) === 'granted'))){
            const files = await traverseDirHandle(stored);
            if(files.length) return startScan(files);
          }
        }catch(e){ console.warn('Stored handle failed; falling back', e); }
      }

      if(window.showDirectoryPicker){
        try{
          const dirHandle = await window.showDirectoryPicker();
          const files = await traverseDirHandle(dirHandle);
          let handleId = null;
          if(rememberFolder.checked){ try{ handleId = await saveSavedHandle(dirHandle); }catch(e){ console.warn('Storing handle failed', e); } }
          await renderSavedFolders();
          if(!files.length){ alert('No files found in chosen folder.'); return; }
          startScan(files, { handleId, name: dirHandle.name });
          return;
        }catch(err){
          console.warn('Directory pick cancelled or failed, falling back to file input', err);
        }
      }

      // fallback behavior (existing): open file picker if no files already selected
      if(!folderPicker.files.length){ folderPicker.click(); return; }
      startScan(Array.from(folderPicker.files));
    });

    clearSavedBtn.addEventListener('click', async ()=>{
      // Clear all saved handles
      try{
        const items = await listAllSavedHandles();
        for(const it of items) await removeHandle(it.id).catch(()=>{});
        await renderSavedFolders();
        savedFolderArea.style.display='none';
        rememberFolder.checked = false;
        savedFolderLabel.textContent = '';
        alert('All saved folders cleared.');
      }catch(e){ console.warn(e); alert('Failed to clear saved folders.'); }
    });

    folderPicker.addEventListener('change', ()=>{
      if(folderPicker.files.length){
        startScan(Array.from(folderPicker.files));
      }
    });

    clearBtn.addEventListener('click', ()=>{
      folderPicker.value = '';
      resultsSection.style.display = 'none';
      progressArea.style.display = 'none';
      lastScan = null;
    });

    runBtn.addEventListener('click', async ()=>{
      if(!lastScan){ alert('Please scan a folder first.'); return; }
      setSpinner(true);
      // In this preview we mark the latest saved scan as run-successful (UI-level).
      if(lastSavedScanId){
        await markScanSuccess(lastSavedScanId);
        setSpinner(false);
        alert('Marked saved scan as completed (UI). To actually produce archives, run the repack script from your shell (see README).');
        return;
      }
      // If we don't have the saved id, try to find a recent scan matching count+size
      const scans = await listScans().catch(()=>[]);
      const candidate = scans.find(s=>s.rec && s.rec.count === lastScan.fileInfos.length && s.rec.totalOrig === lastScan.totalBytes);
      if(candidate){ await markScanSuccess(candidate.id); setSpinner(false); alert('Marked recent saved scan as completed (UI).'); return; }
      setSpinner(false);
      alert('No matching saved scan record found to mark as completed. The repack script `repack_by_type.js` can produce output archives from a folder path.');
    });

    async function startScan(files, meta={}){
      setSpinner(true);
      progressArea.style.display = '';
      progressBar.style.width = '0%';
      resultsSection.style.display = 'none';
      updateProgress(0, files.length);

      const extMap = new Map();
      let totalBytes = 0;
      const fileInfos = [];

      const maxFiles = parseInt(document.getElementById('maxFiles').shadowRoot? document.getElementById('maxFiles').shadowRoot.querySelector('input').value : document.getElementById('maxFiles').value) || 0;
      const extFilterRaw = document.getElementById('extensions').shadowRoot? document.getElementById('extensions').shadowRoot.querySelector('input').value : document.getElementById('extensions').value;
      const extFilter = (extFilterRaw||'').split(/\s+/).filter(Boolean).map(e=>e.toLowerCase());

      let processed = 0;
      for(const f of files){
        // Optionally stop if over maxFiles
        if(maxFiles>0 && processed>=maxFiles) break;
        // ignore directories (they may appear as zero-length entries)
        if(f.size === undefined) continue;

        const name = f.name || 'unknown';
        const dot = name.lastIndexOf('.');
        const ext = dot>-1 ? name.slice(dot).toLowerCase() : '(no ext)';
        if(extFilter.length && !extFilter.includes(ext)){
          processed++; updateProgress(processed, files.length); await new Promise(r=>setTimeout(r,0)); continue;
        }

        const prev = extMap.get(ext) || {count:0, bytes:0};
        prev.count += 1;
        prev.bytes += f.size;
        extMap.set(ext, prev);

        totalBytes += f.size;
        fileInfos.push({name, size:f.size, ext});

        processed++;
        if(processed % 50 === 0) {
          updateProgress(processed, files.length);
          await new Promise(r=>setTimeout(r,10));
        } else {
          updateProgress(processed, files.length);
        }
      }

      // finalize
      setSpinner(false);
      progressArea.style.display = 'none';

      // Prepare chart data
      const typeLabels = Array.from(extMap.keys());
      const typeCounts = typeLabels.map(k=>extMap.get(k).count);
      const typeBytes = typeLabels.map(k=>extMap.get(k).bytes);

      // compute estimated compressed bytes (simple heuristic per extension)
      function estimateCompressedBytes(fileInfos){
        const ratioByExt = {
          '.png': 0.6, '.jpg': 0.95, '.jpeg': 0.95, '.tif':0.6, '.tiff':0.6,
          '.json':0.3, '.txt':0.25, '.csv':0.25, '.xml':0.3
        };
        const byExt = new Map();
        for(const f of fileInfos){
          const r = ratioByExt[f.ext] ?? 0.7;
          const comp = Math.round(f.size * r);
          const prev = byExt.get(f.ext) || {orig:0, comp:0, count:0};
          prev.orig += f.size; prev.comp += comp; prev.count += 1;
          byExt.set(f.ext, prev);
        }
        return {byExt, totalOrig: fileInfos.reduce((s,f)=>s+f.size,0), totalComp: fileInfos.reduce((s,f)=>s+Math.round(f.size * (ratioByExt[f.ext]??0.7)),0)};
      }

      const est = estimateCompressedBytes(fileInfos);

      // top files by size
      fileInfos.sort((a,b)=>b.size-a.size);
      const topN = fileInfos.slice(0,10);

      renderCharts(typeLabels, typeCounts, typeBytes, totalBytes, est);

      // populate topFiles list
      topFiles.innerHTML = '';
      for(const fi of topN){
        const li = document.createElement('md-list-item');
        li.setAttribute('headline', fi.name);
        li.setAttribute('supporting-text', fmtBytes(fi.size) + ' — ' + fi.ext);
        topFiles.appendChild(li);
      }

      // show compression summary
      if(est && est.totalOrig !== undefined){
        compressionSummary.style.display = '';
        const saved = est.totalOrig - est.totalComp;
        const pct = est.totalOrig? Math.round((saved/est.totalOrig)*100):0;
        estText.textContent = `${fmtBytes(est.totalOrig)} → ${fmtBytes(est.totalComp)} (saved ${fmtBytes(saved)} — ${pct}%)`;
      }

      resultsSection.style.display = '';
      lastScan = {extMap, totalBytes, fileInfos};

      // Save a short scan record (does not store all File objects)
      try{
        const folderName = meta && meta.name ? meta.name : (files && files.length && files[0].webkitRelativePath ? files[0].webkitRelativePath.split('/')[0] : 'Scan ' + new Date().toLocaleString());
        const scanRec = { name: folderName, ts: Date.now(), count: fileInfos.length, totalOrig: est.totalOrig || 0, totalComp: est.totalComp || 0, handleId: meta && meta.handleId ? meta.handleId : null };
        const sid = 's' + Date.now();
        lastSavedScanId = sid;
        await putScan(sid, scanRec).catch(()=>{});
        await renderScans();
      }catch(e){ console.warn('Saving scan record failed', e); }
    }

    let typeChart=null, sizeChart=null;
    function renderCharts(labels, counts, bytesArr, totalBytes, est){
      const ctx1 = document.getElementById('typeChart').getContext('2d');
      const ctx2 = document.getElementById('sizeChart').getContext('2d');
      if(typeChart) typeChart.destroy();
      if(sizeChart) sizeChart.destroy();

      typeChart = new Chart(ctx1, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: counts,
            backgroundColor: labels.map((_,i)=>`hsl(${(i*47)%360} 70% 55%)`),
            hoverOffset: 6
          }]
        },
        options: {plugins:{legend:{position:'right'}}}
      });

      // prepare pre/post compression datasets if estimate provided
      const preData = bytesArr.map(b=>b/1024/1024);
      let compData = null;
      if(est && est.byExt){
        compData = labels.map(l=>{
          const v = est.byExt.get(l);
          return v? (v.comp/1024/1024) : 0;
        });
      }

      const datasets = [{
        label: 'Original (MB)',
        data: preData,
        backgroundColor: labels.map((_,i)=>`hsl(${(i*47)%360} 60% 45%)`)
      }];
      if(compData){
        datasets.push({
          label: 'Estimated Compressed (MB)',
          data: compData,
          backgroundColor: labels.map((_,i)=>`hsl(${(i*47)%360} 80% 75%)`)
        });
      }

      sizeChart = new Chart(ctx2, {
        type: 'bar',
        data: { labels: labels, datasets },
        options: {scales:{y:{title:{display:true,text:'MB'}}}, plugins:{legend:{position:'right'}}}
      });
    }
      // Theme toggle: read saved preference, apply class, and persist changes
      const themeToggle = document.getElementById('themeToggle');
      function updateThemeUI(){
        if(!themeToggle) return;
        const icon = themeToggle.querySelector('span.material-symbols-outlined');
        const isDark = document.body.classList.contains('dark');
        if(icon) icon.textContent = isDark ? 'light_mode' : 'dark_mode';
        themeToggle.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
      }
      (function initTheme(){
        const saved = localStorage.getItem('theme');
        if(saved === 'dark') document.body.classList.add('dark');
        else if(saved === 'light') document.body.classList.remove('dark');
        else if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) document.body.classList.add('dark');
        updateThemeUI();
      })();
      if(themeToggle){
        themeToggle.addEventListener('click', ()=>{
          const isDark = document.body.classList.toggle('dark');
          localStorage.setItem('theme', isDark ? 'dark' : 'light');
          updateThemeUI();
        });
      }
      const menuBtn = document.getElementById('menuBtn');
      if(menuBtn){
        menuBtn.addEventListener('click', ()=>{
          const s = document.getElementById('scansSection');
          if(s) s.style.display = (s.style.display === 'none' || s.style.display === '') ? '' : 'none';
          // ensure saved scans are rendered when opening
          renderScans().catch(()=>{});
        });
      }
      // Wire mobile toolbar buttons
      const mobileScanBtn = document.getElementById('mobileScanBtn');
      const mobileChooseBtn = document.getElementById('mobileChooseBtn');
      const mobileRunBtn = document.getElementById('mobileRunBtn');
      const mobileClearBtn = document.getElementById('mobileClearBtn');
      const mobileThemeBtn = document.getElementById('mobileThemeBtn');
      if(mobileScanBtn) mobileScanBtn.addEventListener('click', ()=> scanBtn.click());
      if(mobileChooseBtn) mobileChooseBtn.addEventListener('click', ()=> chooseFolderBtn.click());
      if(mobileRunBtn) mobileRunBtn.addEventListener('click', ()=> runBtn.click());
      if(mobileClearBtn) mobileClearBtn.addEventListener('click', ()=> clearBtn.click());
      if(mobileThemeBtn) mobileThemeBtn.addEventListener('click', ()=> themeToggle.click());
      const clearAllScansBtn = document.getElementById('clearAllScans');
      if(clearAllScansBtn){
        clearAllScansBtn.addEventListener('click', async ()=>{
          const items = await listScans().catch(()=>[]);
          for(const it of items) await removeScan(it.id).catch(()=>{});
          await renderScans();
          alert('All saved scans cleared.');
        });
      }
  </script>
</body>
</html>
