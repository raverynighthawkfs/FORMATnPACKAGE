<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FORMATnPACKAGE – UI Preview</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24..48,300..700,0..1,-50..200&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/theme.css">
  <link rel="stylesheet" href="../styles/layout.css">
  <!-- Import map for Material Web -->
  <script type="importmap">
    {
      "imports": {
        "@material/web/": "https://unpkg.com/@material/web@1.5.1/"
      }
    }
  </script>
  <script type="module">
    import "@material/web/button/filled-button.js";
    import "@material/web/textfield/filled-text-field.js";
    import "@material/web/icon/icon.js";
    import "@material/web/iconbutton/filled-icon-button.js";
    import "@material/web/list/list.js";
    import "@material/web/list/list-item.js";
    import "@material/web/chips/assist-chip.js";
  </script>
</head>
<body>
  <header class="app-bar">
    <span class="material-symbols-outlined">inventory_2</span>
    <div class="app-title">FORMATnPACKAGE</div>
  </header>

  <main class="container">
    <section class="section">
      <h3>Inputs</h3>
      <div class="grid">
        <div>
          <label for="folderPicker" class="label">Select folder to scan</label>
          <input id="folderPicker" type="file" webkitdirectory directory multiple style="width:100%; padding:.5rem;" />
        </div>
        <div>
          <md-filled-text-field id="maxFiles" label="Max files to process (0 = all)" type="number" value="0"></md-filled-text-field>
        </div>
        <div>
          <md-filled-text-field id="extensions" label="Extensions filter (space-separated)" value=".tif .tiff .png .jpg .json .txt"></md-filled-text-field>
        </div>
        <div>
          <md-filled-text-field id="outputDir" label="Output directory" value="C:\\Users\\ravery\\Desktop\\compression_results"></md-filled-text-field>
        </div>
      </div>

      <div style="margin-top:1rem; display:flex; gap:.5rem; align-items:center;">
        <md-filled-button id="scanBtn">
          <span class="material-symbols-outlined" slot="icon">search</span>
          Scan
        </md-filled-button>
        <md-filled-button id="chooseFolderBtn" appearance="outlined">
          <span class="material-symbols-outlined" slot="icon">folder_open</span>
          Choose folder
        </md-filled-button>
        <md-filled-button id="runBtn">
          <span class="material-symbols-outlined" slot="icon">play_arrow</span>
          Run
        </md-filled-button>
        <md-filled-button appearance="tonal" id="clearBtn">
          <span class="material-symbols-outlined" slot="icon">refresh</span>
          Clear
        </md-filled-button>
        <label style="display:flex; align-items:center; gap:.25rem; margin-left:8px; white-space:nowrap;">
          <input type="checkbox" id="rememberFolder" />
          <small>Remember folder</small>
        </label>
        <div id="savedFolderArea" style="display:none; margin-left:8px; align-items:center; gap:.5rem;">
          <div id="savedFolderLabel" style="font-size:0.85rem; opacity:0.9"></div>
          <md-filled-button id="clearSavedBtn" appearance="outlined">Forget</md-filled-button>
        </div>
        <div id="spinner" class="spinner hidden" title="Scanning"></div>
      </div>

      <div id="progressArea" class="section" style="margin-top:1rem; display:none;">
        <div style="display:flex; align-items:center; gap:1rem;">
          <div style="flex:1">
            <div id="progressBarContainer" class="progress-bar-container"><div id="progressBar" class="progress-bar" style="width:0%"></div></div>
          </div>
          <div id="progressText">0 / 0</div>
        </div>
      </div>
      <div id="compressionSummary" style="margin-top:.75rem; display:none;">
        <strong>Estimated packaging:</strong>
        <div id="estText" style="font-size:.95rem; margin-top:.25rem"></div>
      </div>
    </section>

    <section class="section" id="resultsSection" style="display:none;">
      <h3>Scan Results</h3>
      <div class="grid">
        <div>
          <canvas id="typeChart" width="400" height="250"></canvas>
        </div>
        <div>
          <canvas id="sizeChart" width="400" height="250"></canvas>
        </div>
      </div>

      <h4 style="margin-top:1rem">Top files (by size)</h4>
      <md-list id="topFiles"></md-list>
    </section>

    <div class="footer">This preview scans a selected folder in-browser (no server). Use the folder picker to choose files.</div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Helper functions
    function fmtBytes(bytes){
      if(bytes===0) return '0 B';
      const sizes=['B','KB','MB','GB','TB'];
      const i=Math.floor(Math.log(bytes)/Math.log(1024));
      return (bytes/Math.pow(1024,i)).toFixed(i?1:0)+' '+sizes[i];
    }

    const folderPicker = document.getElementById('folderPicker');
    const scanBtn = document.getElementById('scanBtn');
    const chooseFolderBtn = document.getElementById('chooseFolderBtn');
    const runBtn = document.getElementById('runBtn');
    const clearBtn = document.getElementById('clearBtn');
    const spinner = document.getElementById('spinner');
    const progressArea = document.getElementById('progressArea');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const resultsSection = document.getElementById('resultsSection');
    const topFiles = document.getElementById('topFiles');

    let lastScan = null;
    const rememberFolder = document.getElementById('rememberFolder');
    const savedFolderArea = document.getElementById('savedFolderArea');
    const savedFolderLabel = document.getElementById('savedFolderLabel');
    const clearSavedBtn = document.getElementById('clearSavedBtn');
    const compressionSummary = document.getElementById('compressionSummary');
    const estText = document.getElementById('estText');

    function setSpinner(show){
      spinner.classList.toggle('hidden', !show);
    }

    function updateProgress(done, total){
      const pct = total? Math.round((done/total)*100):0;
      progressBar.style.width = pct + '%';
      progressText.textContent = `${done} / ${total}`;
    }

    // File System Access API helpers + IndexedDB persistence helpers
    const DB_NAME = 'FORMATnPACKAGE_handles_v1';
    function openDB(){
      return new Promise((resolve, reject)=>{
        const r = indexedDB.open(DB_NAME, 1);
        r.onupgradeneeded = ()=>{
          const db = r.result;
          if(!db.objectStoreNames.contains('handles')) db.createObjectStore('handles');
        };
        r.onsuccess = ()=>resolve(r.result);
        r.onerror = ()=>reject(r.error);
      });
    }
    async function putHandle(key, handle){
      const db = await openDB();
      return new Promise((res, rej) => {
        const tx = db.transaction('handles','readwrite');
        tx.objectStore('handles').put(handle, key);
        tx.oncomplete = () => res();
        tx.onerror = () => rej(tx.error);
      });
    }
    async function getHandle(key){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('handles','readonly');
        const req = tx.objectStore('handles').get(key);
        req.onsuccess = ()=>res(req.result);
        req.onerror = ()=>rej(req.error);
      });
    }
    async function removeHandle(key){
      const db = await openDB();
      return new Promise((res, rej)=>{
        const tx = db.transaction('handles','readwrite');
        tx.objectStore('handles').delete(key);
        tx.oncomplete = ()=>res();
        tx.onerror = ()=>rej(tx.error);
      });
    }

    async function traverseDirHandle(dirHandle){
      const files = [];
      async function traverse(handle){
        for await (const entry of handle.values()){
          if(entry.kind === 'file'){
            try{ files.push(await entry.getFile()); }catch(e){}
          } else if(entry.kind === 'directory'){
            await traverse(entry);
          }
        }
      }
      await traverse(dirHandle);
      return files;
    }

    async function useStoredHandleIfAvailable(){
      try{
        const stored = await getHandle('dir');
        if(stored){
          // ask for permission if needed
          if(typeof stored.requestPermission === 'function'){
            const perm = await stored.requestPermission({mode:'read'});
            if(perm === 'granted'){
              const files = await traverseDirHandle(stored);
              return {handle: stored, files};
            }
          } else {
            // try to iterate (some browsers auto-grant)
            const files = await traverseDirHandle(stored);
            return {handle: stored, files};
          }
        }
      }catch(e){ console.warn('No stored handle available or permission denied', e); }
      return null;
    }

    // Choose folder button — explicit picking
    chooseFolderBtn.addEventListener('click', async ()=>{
      if(!window.showDirectoryPicker){
        alert('Directory picker is not supported in this browser. Use the folder picker input.');
        folderPicker.click();
        return;
      }
      try{
        const dirHandle = await window.showDirectoryPicker();
        const files = await traverseDirHandle(dirHandle);
        if(rememberFolder.checked){
          try{ await putHandle('dir', dirHandle); savedFolderArea.style.display='flex'; savedFolderLabel.textContent = dirHandle.name; }catch(e){ console.warn('Storing handle failed', e); }
        }
        startScan(files);
      }catch(e){ console.warn('Directory pick cancelled', e); }
    });

    // Load stored handle on startup
    (async ()=>{
      try{
        const s = await useStoredHandleIfAvailable();
        if(s){
          savedFolderArea.style.display='flex';
          savedFolderLabel.textContent = s.handle.name || 'Saved folder';
          rememberFolder.checked = true;
        }
      }catch(e){}
    })();

    // Try to use the File System Access API to pick a directory (better UX)
    // Fallback: use the hidden file input with webkitdirectory
    scanBtn.addEventListener('click', async ()=>{
      // If we have a stored handle and user wants it, try to use it
      const stored = await getHandle('dir').catch(()=>null);
      if(stored){
        try{
          const perm = stored.queryPermission ? await stored.queryPermission({mode:'read'}) : 'prompt';
          if(perm === 'granted' || (perm === 'prompt' && (await stored.requestPermission({mode:'read'}) === 'granted'))){
            const files = await traverseDirHandle(stored);
            if(files.length) return startScan(files);
          }
        }catch(e){ console.warn('Stored handle failed; falling back', e); }
      }

      if(window.showDirectoryPicker){
        try{
          const dirHandle = await window.showDirectoryPicker();
          const files = await traverseDirHandle(dirHandle);
          if(rememberFolder.checked){ try{ await putHandle('dir', dirHandle); savedFolderArea.style.display='flex'; savedFolderLabel.textContent = dirHandle.name; }catch(e){ console.warn('Storing handle failed', e); } }
          if(!files.length){ alert('No files found in chosen folder.'); return; }
          startScan(files);
          return;
        }catch(err){
          console.warn('Directory pick cancelled or failed, falling back to file input', err);
        }
      }

      // fallback behavior (existing): open file picker if no files already selected
      if(!folderPicker.files.length){ folderPicker.click(); return; }
      startScan(Array.from(folderPicker.files));
    });

    clearSavedBtn.addEventListener('click', async ()=>{
      await removeHandle('dir').catch(()=>{});
      savedFolderArea.style.display='none';
      rememberFolder.checked = false;
      savedFolderLabel.textContent = '';
      alert('Saved folder cleared.');
    });

    folderPicker.addEventListener('change', ()=>{
      if(folderPicker.files.length){
        startScan(Array.from(folderPicker.files));
      }
    });

    clearBtn.addEventListener('click', ()=>{
      folderPicker.value = '';
      resultsSection.style.display = 'none';
      progressArea.style.display = 'none';
      lastScan = null;
    });

    runBtn.addEventListener('click', ()=>{
      // Placeholder: in-app run
      if(!lastScan){ alert('Please scan a folder first.'); return; }
      alert('Run would execute repacking on scanned files (not implemented in preview).');
    });

    async function startScan(files){
      setSpinner(true);
      progressArea.style.display = '';
      progressBar.style.width = '0%';
      resultsSection.style.display = 'none';
      updateProgress(0, files.length);

      const extMap = new Map();
      let totalBytes = 0;
      const fileInfos = [];

      const maxFiles = parseInt(document.getElementById('maxFiles').shadowRoot? document.getElementById('maxFiles').shadowRoot.querySelector('input').value : document.getElementById('maxFiles').value) || 0;
      const extFilterRaw = document.getElementById('extensions').shadowRoot? document.getElementById('extensions').shadowRoot.querySelector('input').value : document.getElementById('extensions').value;
      const extFilter = (extFilterRaw||'').split(/\s+/).filter(Boolean).map(e=>e.toLowerCase());

      let processed = 0;
      for(const f of files){
        // Optionally stop if over maxFiles
        if(maxFiles>0 && processed>=maxFiles) break;
        // ignore directories (they may appear as zero-length entries)
        if(f.size === undefined) continue;

        const name = f.name || 'unknown';
        const dot = name.lastIndexOf('.');
        const ext = dot>-1 ? name.slice(dot).toLowerCase() : '(no ext)';
        if(extFilter.length && !extFilter.includes(ext)){
          processed++; updateProgress(processed, files.length); await new Promise(r=>setTimeout(r,0)); continue;
        }

        const prev = extMap.get(ext) || {count:0, bytes:0};
        prev.count += 1;
        prev.bytes += f.size;
        extMap.set(ext, prev);

        totalBytes += f.size;
        fileInfos.push({name, size:f.size, ext});

        processed++;
        if(processed % 50 === 0) {
          updateProgress(processed, files.length);
          await new Promise(r=>setTimeout(r,10));
        } else {
          updateProgress(processed, files.length);
        }
      }

      // finalize
      setSpinner(false);
      progressArea.style.display = 'none';

      // Prepare chart data
      const typeLabels = Array.from(extMap.keys());
      const typeCounts = typeLabels.map(k=>extMap.get(k).count);
      const typeBytes = typeLabels.map(k=>extMap.get(k).bytes);

      // compute estimated compressed bytes (simple heuristic per extension)
      function estimateCompressedBytes(fileInfos){
        const ratioByExt = {
          '.png': 0.6, '.jpg': 0.95, '.jpeg': 0.95, '.tif':0.6, '.tiff':0.6,
          '.json':0.3, '.txt':0.25, '.csv':0.25, '.xml':0.3
        };
        const byExt = new Map();
        for(const f of fileInfos){
          const r = ratioByExt[f.ext] ?? 0.7;
          const comp = Math.round(f.size * r);
          const prev = byExt.get(f.ext) || {orig:0, comp:0, count:0};
          prev.orig += f.size; prev.comp += comp; prev.count += 1;
          byExt.set(f.ext, prev);
        }
        return {byExt, totalOrig: fileInfos.reduce((s,f)=>s+f.size,0), totalComp: fileInfos.reduce((s,f)=>s+Math.round(f.size * (ratioByExt[f.ext]??0.7)),0)};
      }

      const est = estimateCompressedBytes(fileInfos);

      // top files by size
      fileInfos.sort((a,b)=>b.size-a.size);
      const topN = fileInfos.slice(0,10);

      renderCharts(typeLabels, typeCounts, typeBytes, totalBytes, est);

      // populate topFiles list
      topFiles.innerHTML = '';
      for(const fi of topN){
        const li = document.createElement('md-list-item');
        li.setAttribute('headline', fi.name);
        li.setAttribute('supporting-text', fmtBytes(fi.size) + ' — ' + fi.ext);
        topFiles.appendChild(li);
      }

      // show compression summary
      if(est && est.totalOrig !== undefined){
        compressionSummary.style.display = '';
        const saved = est.totalOrig - est.totalComp;
        const pct = est.totalOrig? Math.round((saved/est.totalOrig)*100):0;
        estText.textContent = `${fmtBytes(est.totalOrig)} → ${fmtBytes(est.totalComp)} (saved ${fmtBytes(saved)} — ${pct}%)`;
      }

      resultsSection.style.display = '';
      lastScan = {extMap, totalBytes, fileInfos};
    }

    let typeChart=null, sizeChart=null;
    function renderCharts(labels, counts, bytesArr, totalBytes, est){
      const ctx1 = document.getElementById('typeChart').getContext('2d');
      const ctx2 = document.getElementById('sizeChart').getContext('2d');
      if(typeChart) typeChart.destroy();
      if(sizeChart) sizeChart.destroy();

      typeChart = new Chart(ctx1, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: counts,
            backgroundColor: labels.map((_,i)=>`hsl(${(i*47)%360} 70% 55%)`),
            hoverOffset: 6
          }]
        },
        options: {plugins:{legend:{position:'right'}}}
      });

      // prepare pre/post compression datasets if estimate provided
      const preData = bytesArr.map(b=>b/1024/1024);
      let compData = null;
      if(est && est.byExt){
        compData = labels.map(l=>{
          const v = est.byExt.get(l);
          return v? (v.comp/1024/1024) : 0;
        });
      }

      const datasets = [{
        label: 'Original (MB)',
        data: preData,
        backgroundColor: labels.map((_,i)=>`hsl(${(i*47)%360} 60% 45%)`)
      }];
      if(compData){
        datasets.push({
          label: 'Estimated Compressed (MB)',
          data: compData,
          backgroundColor: labels.map((_,i)=>`hsl(${(i*47)%360} 80% 75%)`)
        });
      }

      sizeChart = new Chart(ctx2, {
        type: 'bar',
        data: { labels: labels, datasets },
        options: {scales:{y:{title:{display:true,text:'MB'}}}, plugins:{legend:{position:'right'}}}
      });
    }
  </script>
</body>
</html>
